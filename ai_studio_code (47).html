<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>The One Night Gathering</title>
    <style>
        /* 第一层：最底层固定黑色 */
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: #000000;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            touch-action: none;
        }

        /* 核心容器：舞台 */
        /* 尺寸锁定为 1124x2436 */
        #stage {
            position: relative;
            width: 1124px;
            height: 2436px;
            background-color: transparent;
            opacity: 0; 
            transition: opacity 0.5s ease;
            box-shadow: 0 0 100px rgba(0,0,0,0.8);
        }

        /* 第二层：交互层 (Canvas) */
        #fireworksCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
        }

        /* 第三层：最上层图片 */
        #posterImage {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: 20;
            pointer-events: none; /* 点击穿透 */
        }
    </style>
</head>
<body>

    <!-- 舞台容器 -->
    <div id="stage">
        <canvas id="fireworksCanvas" width="1124" height="2436"></canvas>
        <img id="posterImage" src="poster.png" alt="Invitation">
    </div>

    <script>
        // --- 1. 舞台适配逻辑 ---
        const stageWidth = 1124;
        const stageHeight = 2436;
        const stage = document.getElementById('stage');
        const canvas = document.getElementById('fireworksCanvas');
        const ctx = canvas.getContext('2d');
        let currentScale = 1;

        function resizeStage() {
            const screenW = window.innerWidth;
            const screenH = window.innerHeight;
            const scaleW = screenW / stageWidth;
            const scaleH = screenH / stageHeight;
            currentScale = Math.min(scaleW, scaleH);
            stage.style.transform = `scale(${currentScale})`;
            stage.style.opacity = 1;
        }
        window.addEventListener('resize', resizeStage);
        resizeStage();


        // --- 2. 增强版烟花逻辑 (去掉了Heart) ---
        let particles = [];
        
        // 霓虹配色池
        const colors = [
            '#FF00FF', // 紫红
            '#00FFFF', // 青色
            '#39FF14', // 荧光绿
            '#FFD700', // 金色
            '#FF3131', // 霓虹红
            '#1F51FF', // 霓虹蓝
            '#FE019A', // 热粉
            '#FFFFFF'  // 纯白闪烁
        ];

        // 形状列表 (已移除 heart)
        const shapes = ['circle', 'star', 'ring', 'double'];

        class Particle {
            constructor(x, y, shapeType, specialColor = null) {
                this.x = x;
                this.y = y;
                this.color = specialColor || colors[Math.floor(Math.random() * colors.length)];
                this.alpha = 1;
                this.friction = 0.96; 
                this.gravity = 0.4;   
                this.size = Math.random() * 7 + 3; 
                this.decay = Math.random() * 0.015 + 0.01; 

                let angle, force;
                
                switch (shapeType) {
                    case 'star':
                        // 五角星
                        force = Math.random() * 20 + 5;
                        const angleBase = (Math.PI * 2) / 5;
                        angle = (Math.floor(Math.random() * 5) * angleBase) - (Math.PI / 2);
                        angle += (Math.random() * 0.6 - 0.3); // 抖动范围
                        
                        this.vx = Math.cos(angle) * force * 1.5;
                        this.vy = Math.sin(angle) * force * 1.5;
                        break;

                    case 'ring':
                        // 光环
                        angle = Math.random() * Math.PI * 2;
                        force = 18 + Math.random() * 4; 
                        this.vx = Math.cos(angle) * force;
                        this.vy = Math.sin(angle) * force;
                        this.friction = 0.94; 
                        break;
                    
                    case 'double_inner':
                         // 双层爆炸的内圈
                        angle = Math.random() * Math.PI * 2;
                        force = Math.random() * 10 + 2;
                        this.vx = Math.cos(angle) * force;
                        this.vy = Math.sin(angle) * force;
                        break;

                    case 'circle':
                    default:
                        // 经典圆形
                        angle = Math.random() * Math.PI * 2;
                        force = Math.random() * 25 + 2;
                        this.vx = Math.cos(angle) * force;
                        this.vy = Math.sin(angle) * force;
                        break;
                }
            }

            update() {
                this.vx *= this.friction;
                this.vy *= this.friction;
                this.vy += this.gravity;
                this.x += this.vx;
                this.y += this.vy;
                this.alpha -= this.decay;
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = this.alpha;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 15;
                ctx.shadowColor = this.color;
                ctx.fill();
                ctx.restore();
            }
        }

        function createFirework(x, y) {
            const shape = shapes[Math.floor(Math.random() * shapes.length)];
            let particleCount = 200;

            if (shape === 'double') {
                // 外层
                for (let i = 0; i < 150; i++) {
                    particles.push(new Particle(x, y, 'circle')); 
                }
                // 内层
                const innerColor = '#FFFFFF';
                for (let i = 0; i < 100; i++) {
                    particles.push(new Particle(x, y, 'double_inner', innerColor));
                }
            } else if (shape === 'ring') {
                particleCount = 250; 
                for (let i = 0; i < particleCount; i++) {
                    particles.push(new Particle(x, y, shape));
                }
            } else {
                particleCount = 220;
                for (let i = 0; i < particleCount; i++) {
                    particles.push(new Particle(x, y, shape));
                }
            }
        }

        function animate() {
            // 拖尾
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            particles.forEach((particle, index) => {
                if (particle.alpha > 0) {
                    particle.update();
                    particle.draw();
                } else {
                    particles.splice(index, 1);
                }
            });
            requestAnimationFrame(animate);
        }
        animate();


        // --- 3. 交互逻辑 ---
        function getRelativeCoordinates(event) {
            const rect = stage.getBoundingClientRect();
            const clientX = event.clientX;
            const clientY = event.clientY;
            const x = (clientX - rect.left) / currentScale;
            const y = (clientY - rect.top) / currentScale;
            return { x, y };
        }

        function handleInteraction(e) {
            e.preventDefault(); 
            if (e.type.includes('touch')) {
                for (let i = 0; i < e.touches.length; i++) {
                    const touch = e.touches[i];
                    const mockEvent = { clientX: touch.clientX, clientY: touch.clientY };
                    const coords = getRelativeCoordinates(mockEvent);
                    if(coords.x >= 0 && coords.x <= stageWidth && coords.y >= 0 && coords.y <= stageHeight) {
                        createFirework(coords.x, coords.y);
                    }
                }
            } else {
                const coords = getRelativeCoordinates(e);
                createFirework(coords.x, coords.y);
            }
        }

        window.addEventListener('mousedown', handleInteraction);
        window.addEventListener('touchstart', handleInteraction, {passive: false});

    </script>
</body>
</html>